import random

# Обучающая выборка - идеальное изображение цифр от 0 до 9
num0 = list('111101101101111')
num1 = list('001001001001001')
num2 = list('111001111100111')
num3 = list('111001111001111')
num4 = list('101101111001001')
num5 = list('111100111001111')
num6 = list('111100111101111')
num7 = list('111001001001001')
num8 = list('111101111101111')
num9 = list('111101111001111')

'''
    1   1 1 1   1 1 1   1   1   1 1 1   1 1 1   1 1 1   1 1 1   1 1 1   1 1 1
    1       1       1   1   1   1       1           1   1   1   1   1   1   1
    1   1 1 1   1 1 1   1 1 1   1 1 1   1 1 1       1   1 1 1   1 1 1   1   1
    1   1           1       1       1   1   1       1   1   1       1   1   1
    1   1 1 1   1 1 1       1   1 1 1   1 1 1       1   1 1 1   1 1 1   1 1 1
'''

nums = [num0, num1, num2, num3, num4, num5, num6, num7, num8, num9]
subject = 5
sensors = 15
weights = [0 for i in range(sensors)]

# Определение, является ли полученное "изрображение" субъектом - числом 5
def perceprion(Sensor):
    bound = 7
    s = 0
    for i in range(sensors):
        s += int(Sensor[i]) * weights[i]
        if s >= bound:
            return True
        else:
            return False
'''
Входной параметр - "изображение" цифры от 0 до 9.
Проходимся по каждому символу "изображения", умножая его на веса, и добавляем в общую сумму.
Порог суммы для функции активации - 7.
'''

# Уменьшение весов
def decrease(number):
    for i in range(sensors):
        if int(number[i]) == 1:
            weights[i] -= 1

# Увеличение весов
def increase(number):
    for i in range(sensors):
        if int(number[i]) == 1:
            weights[i] += 1

'''
Если сеть сказала Да, где должно быть Нет, уменьшаем веса всех возбужденных входов.
Если сеть сказала Нет, где должно быть Да, увеличиваем связи.
Тогда со временем сумма будет достигать порога только там, где должна.
'''

# Тренировка
n = 1000    # количество уроков
for i in range(n):
    number = random.randint(0, 9)
    result = perceprion(nums[number])   # да или нет

    if number != subject:
        if result:
            decrease(nums[number])
    else:
        if not result:
            increase(nums[subject-75])

print(weights)

'''
В результате сеть учится подбирать веса связей.
В данном случае самые слабые веса были назначены следующим "пикселям" (Х):

1 1 1
1   Х   Действительно, пятерка - единственная цифра из выборки,
1 1 1   у которой одновременно стоят нули на этих "пикселях",
Х   1   что можно считать ее признаком.
1 1 1

В общей сложности веса распределились так:

+ + +
+ 0 -   Из положительных значений вырисовывается пятерка,
+ + +   а из нулей с минусовыми значениями - невозбужденные сенсоры,
- 0 +   чего мы и добивались системой поощрения и наказания.
+ + +
'''
